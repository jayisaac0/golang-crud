package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"

	validation "github.com/go-ozzo/ozzo-validation"
	"github.com/go-ozzo/ozzo-validation/is"
	"github.com/gorilla/mux"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/postgres"
	uuid "github.com/satori/go.uuid"
)

var db *gorm.DB
var err error

// Base contains common columns for all tables.
type Base struct {
	ID        uuid.UUID  `gorm:"type:uuid;primary_key;"`
	CreatedAt time.Time  `json:"created_at"`
	UpdatedAt time.Time  `json:"update_at"`
	DeletedAt *time.Time `sql:"index" json:"deleted_at"`
}

// BeforeCreate will set a UUID rather than numeric ID.
func (base *Base) BeforeCreate(tx *gorm.DB) (err error) {
	base.ID = uuid.NewV4()
	return
}

// User struct
type User struct {
	Base
	Username string `json:"Username"`
	Email    string `json:"Email"`
	Password string `json:"Password"`
}

// UserUpdate struct
type UserUpdate struct {
	Username string `json:"Username"`
	Email    string `json:"Email"`
}

// Validate struct
func (user User) Validate() error {
	return validation.ValidateStruct(&user,
		validation.Field(&user.Username, validation.Required, validation.Length(4, 50)),
		validation.Field(&user.Email, validation.Required, is.Email, validation.Length(4, 50)),
		validation.Field(&user.Password, validation.Required, validation.Length(4, 50)),
	)
}

// Validate struct
func (updateuser UserUpdate) Validate() error {
	return validation.ValidateStruct(&updateuser,
		validation.Field(&updateuser.Username, validation.Required, validation.Length(4, 50)),
		validation.Field(&updateuser.Email, validation.Required, is.Email, validation.Length(4, 50)),
	)
}

// connectionError function
func connectionError() {
	db, err = gorm.Open("postgres", "host=localhost port=5432 user=postgres dbname=go_test_db sslmode=disable password=postgres")
	if err != nil {
		panic("could not connect to database")
	}
	defer db.Close()
}

// initialMigration and run
func initialMigration() {
	db, err = gorm.Open("postgres", "host=localhost port=5432 user=postgres dbname=go_test_db sslmode=disable password=postgres")
	if err != nil {
		fmt.Println(err.Error())
		panic("FAILED TO CONNECT")
	}
	defer db.Close()
	db.AutoMigrate(&User{})
}

// Users array
type users []User

// create user
func create(w http.ResponseWriter, r *http.Request) {

	var user User
	json.NewDecoder(r.Body).Decode(&user)

	err := user.Validate()
	if err != nil {
		json.NewEncoder(w).Encode(&err)
		return
	}

	db.Create(&user)
	json.NewEncoder(w).Encode(&user)
	return
}

// fetchAll user
func fetchAll(w http.ResponseWriter, r *http.Request) {
	var users []User
	db.Find(&users)
	json.NewEncoder(w).Encode(&users)
	return
}

// fetchRecord user
func fetchRecord(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	var user User

	if err := db.Where("ID = ?", params["ID"]).First(&user).Error; err != nil {
		// error handling...
		fmt.Fprint(w, err)
		return
	}

	// db.Where("Username = ?", params["ID"]).First(&user)
	json.NewEncoder(w).Encode(&user)
	return
}

// updateRecord user
func updateRecord(w http.ResponseWriter, r *http.Request) {
	// params := mux.Vars(r)

	// var updateuser UserUpdate
	// json.NewDecoder(r.Body).Decode(&updateuser)

	// err := updateuser.Validate()
	// if err != nil {
	// 	json.NewEncoder(w).Encode(&err)
	// 	return
	// }

	// db.Model(&updateuser).Where("ID = ?", params["ID"]).Update(&UserUpdate{
	// 	Username: updateuser.Username,
	// 	Email:    updateuser.Email,
	// })
	// return

	params := mux.Vars(r)

	var user User
	var updateuser UserUpdate

	json.NewDecoder(r.Body).Decode(&updateuser)

	err := updateuser.Validate()
	if err != nil {
		json.NewEncoder(w).Encode(&err)
		return
	}

	db.Model(&user).Where("ID = ?", params["ID"]).Update(&updateuser)
	return
}

// deleteRecord user
func deleteRecord(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	var user User

	db.Where("ID = ?", params["ID"]).Delete(&user)

	var users []User
	db.Find(&users)
	json.NewEncoder(w).Encode(&users)
}

// handleRequets
func handleRequets() {
	myRouter := mux.NewRouter().StrictSlash(true)

	// db, err = gorm.Open("postgres", os.ExpandEnv("host=${HOST} user=${USER} dbname=${DBNAME} sslmode=disable password=${PASSWORD}"))

	db, err = gorm.Open("postgres", "host=localhost port=5432 user=postgres dbname=go_test_db sslmode=disable password=postgres")
	if err != nil {
		panic("could not connect to database")
	}
	defer db.Close()

	myRouter.HandleFunc("/create", create).Methods("POST")
	myRouter.HandleFunc("/fetch", fetchAll).Methods("GET")
	myRouter.HandleFunc("/fetch/{ID}", fetchRecord).Methods("GET")
	myRouter.HandleFunc("/update/{ID}", updateRecord).Methods("PATCH")
	myRouter.HandleFunc("/delete/{ID}", deleteRecord).Methods("DELETE")

	// s := &http.Server{
	// 	Addr:           ":8080",
	// 	Handler:        myRouter,
	// 	ReadTimeout:    10 * time.Second,
	// 	WriteTimeout:   10 * time.Second,
	// 	MaxHeaderBytes: 1 << 20,
	// }

	fmt.Println("Server listening to port 8000")

	if err := http.ListenAndServe(":8000", myRouter); err != nil {
		log.Fatal(http.ListenAndServe(":8000", myRouter))
	}
}

func main() {
	initialMigration()
	handleRequets()
}
